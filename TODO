#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Define structures for different object types
typedef struct {
    double x, y, z;
    double radius;
} Sphere;

typedef struct {
    double x, y, z;
    double size;
} Cube;

// Define a common structure with a function pointer for the hit function
typedef struct Object {
    void *object;
    int (*hit)(void *object, double *t);
} Object;

// Hit function for Sphere
int hit_sphere(void *object, double *t) {
    Sphere *sphere = (Sphere *)object;
    // Implement sphere hit logic here
    // For simplicity, let's assume it always hits
    *t = 1.0;
    return 1;
}

// Hit function for Cube
int hit_cube(void *object, double *t) {
    Cube *cube = (Cube *)object;
    // Implement cube hit logic here
    // For simplicity, let's assume it always hits
    *t = 1.0;
    return 1;
}

int main() {
    // Create objects
    Sphere sphere = {0, 0, -1, 0.5};
    Cube cube = {1, 1, -1, 1.0};

    // Create a list of objects
    Object objects[2];
    objects[0].object = &sphere;
    objects[0].hit = hit_sphere;
    objects[1].object = &cube;
    objects[1].hit = hit_cube;

    // PUT THIS IN RENDER FUNCTION LIKE BELLOW Iterate over the list and call the hit function for each object
    double t;
    for (int i = 0; i < 2; i++) {
        if (objects[i].hit(objects[i].object, &t)) {
            printf("Object %d hit at t = %f\n", i, t);
        }
    }

    return 0;
}

t_vec3 ray_color(t_ray *r, Object *objects, int num_objects) {
    t_vec3 unit_direction;
    double t;
    double closest_t = INFINITY;
    Object *closest_object = NULL;

    // Iterate over the list of objects and find the closest hit
    for (int i = 0; i < num_objects; i++) {
        if (objects[i].hit(objects[i].object, r, &t) && t < closest_t) {
            closest_t = t;
            closest_object = &objects[i];
        }
    }

    if (closest_object != NULL) {
        t_vec3 n;
        n = vector_normalize(vector_subtract(ray_at(r, closest_t), vec3(0, 0, -1)));
        if (dot(n, r->dir) > 0) {
            n.x = -n.x;
            n.y = -n.y;
            n.z = -n.z;
        }
        return vector_scale(vec3(n.x + 1, n.y + 1, n.z + 1), 0.5);
    }

    // Background
    unit_direction = vector_normalize(r->dir);
    t = 0.5 * (unit_direction.y + 1.0);
    return vector_add(vector_scale(vec3(1.0, 1.0, 1.0), 1.0 - t), vector_scale(vec3(0.5, 0.7, 1.0), t));
}